// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'chat_input_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ChatInputEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatInputEventCopyWith<$Res> {
  factory $ChatInputEventCopyWith(
          ChatInputEvent value, $Res Function(ChatInputEvent) then) =
      _$ChatInputEventCopyWithImpl<$Res, ChatInputEvent>;
}

/// @nodoc
class _$ChatInputEventCopyWithImpl<$Res, $Val extends ChatInputEvent>
    implements $ChatInputEventCopyWith<$Res> {
  _$ChatInputEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_UpdateChatInputEventCopyWith<$Res> {
  factory _$$_UpdateChatInputEventCopyWith(_$_UpdateChatInputEvent value,
          $Res Function(_$_UpdateChatInputEvent) then) =
      __$$_UpdateChatInputEventCopyWithImpl<$Res>;
  @useResult
  $Res call({Document message});
}

/// @nodoc
class __$$_UpdateChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_UpdateChatInputEvent>
    implements _$$_UpdateChatInputEventCopyWith<$Res> {
  __$$_UpdateChatInputEventCopyWithImpl(_$_UpdateChatInputEvent _value,
      $Res Function(_$_UpdateChatInputEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$_UpdateChatInputEvent(
      null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as Document,
    ));
  }
}

/// @nodoc

class _$_UpdateChatInputEvent
    with DiagnosticableTreeMixin
    implements _UpdateChatInputEvent {
  const _$_UpdateChatInputEvent(this.message);

  @override
  final Document message;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.update(message: $message)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChatInputEvent.update'))
      ..add(DiagnosticsProperty('message', message));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateChatInputEvent &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateChatInputEventCopyWith<_$_UpdateChatInputEvent> get copyWith =>
      __$$_UpdateChatInputEventCopyWithImpl<_$_UpdateChatInputEvent>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return update(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return update?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return update(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return update?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (update != null) {
      return update(this);
    }
    return orElse();
  }
}

abstract class _UpdateChatInputEvent implements ChatInputEvent {
  const factory _UpdateChatInputEvent(final Document message) =
      _$_UpdateChatInputEvent;

  Document get message;
  @JsonKey(ignore: true)
  _$$_UpdateChatInputEventCopyWith<_$_UpdateChatInputEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_AttachFilesChatInputEventCopyWith<$Res> {
  factory _$$_AttachFilesChatInputEventCopyWith(
          _$_AttachFilesChatInputEvent value,
          $Res Function(_$_AttachFilesChatInputEvent) then) =
      __$$_AttachFilesChatInputEventCopyWithImpl<$Res>;
  @useResult
  $Res call({List<DLSFile> files});
}

/// @nodoc
class __$$_AttachFilesChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_AttachFilesChatInputEvent>
    implements _$$_AttachFilesChatInputEventCopyWith<$Res> {
  __$$_AttachFilesChatInputEventCopyWithImpl(
      _$_AttachFilesChatInputEvent _value,
      $Res Function(_$_AttachFilesChatInputEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? files = null,
  }) {
    return _then(_$_AttachFilesChatInputEvent(
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as List<DLSFile>,
    ));
  }
}

/// @nodoc

class _$_AttachFilesChatInputEvent
    with DiagnosticableTreeMixin
    implements _AttachFilesChatInputEvent {
  const _$_AttachFilesChatInputEvent({required final List<DLSFile> files})
      : _files = files;

  final List<DLSFile> _files;
  @override
  List<DLSFile> get files {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_files);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.attachFiles(files: $files)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChatInputEvent.attachFiles'))
      ..add(DiagnosticsProperty('files', files));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AttachFilesChatInputEvent &&
            const DeepCollectionEquality().equals(other._files, _files));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_files));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AttachFilesChatInputEventCopyWith<_$_AttachFilesChatInputEvent>
      get copyWith => __$$_AttachFilesChatInputEventCopyWithImpl<
          _$_AttachFilesChatInputEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return attachFiles(files);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return attachFiles?.call(files);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (attachFiles != null) {
      return attachFiles(files);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return attachFiles(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return attachFiles?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (attachFiles != null) {
      return attachFiles(this);
    }
    return orElse();
  }
}

abstract class _AttachFilesChatInputEvent implements ChatInputEvent {
  const factory _AttachFilesChatInputEvent(
      {required final List<DLSFile> files}) = _$_AttachFilesChatInputEvent;

  List<DLSFile> get files;
  @JsonKey(ignore: true)
  _$$_AttachFilesChatInputEventCopyWith<_$_AttachFilesChatInputEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_DetachFileChatInputEventCopyWith<$Res> {
  factory _$$_DetachFileChatInputEventCopyWith(
          _$_DetachFileChatInputEvent value,
          $Res Function(_$_DetachFileChatInputEvent) then) =
      __$$_DetachFileChatInputEventCopyWithImpl<$Res>;
  @useResult
  $Res call({String key});
}

/// @nodoc
class __$$_DetachFileChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_DetachFileChatInputEvent>
    implements _$$_DetachFileChatInputEventCopyWith<$Res> {
  __$$_DetachFileChatInputEventCopyWithImpl(_$_DetachFileChatInputEvent _value,
      $Res Function(_$_DetachFileChatInputEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
  }) {
    return _then(_$_DetachFileChatInputEvent(
      null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_DetachFileChatInputEvent
    with DiagnosticableTreeMixin
    implements _DetachFileChatInputEvent {
  const _$_DetachFileChatInputEvent(this.key);

  @override
  final String key;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.detachFile(key: $key)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChatInputEvent.detachFile'))
      ..add(DiagnosticsProperty('key', key));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DetachFileChatInputEvent &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DetachFileChatInputEventCopyWith<_$_DetachFileChatInputEvent>
      get copyWith => __$$_DetachFileChatInputEventCopyWithImpl<
          _$_DetachFileChatInputEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return detachFile(key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return detachFile?.call(key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (detachFile != null) {
      return detachFile(key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return detachFile(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return detachFile?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (detachFile != null) {
      return detachFile(this);
    }
    return orElse();
  }
}

abstract class _DetachFileChatInputEvent implements ChatInputEvent {
  const factory _DetachFileChatInputEvent(final String key) =
      _$_DetachFileChatInputEvent;

  String get key;
  @JsonKey(ignore: true)
  _$$_DetachFileChatInputEventCopyWith<_$_DetachFileChatInputEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ResetChatInputEventCopyWith<$Res> {
  factory _$$_ResetChatInputEventCopyWith(_$_ResetChatInputEvent value,
          $Res Function(_$_ResetChatInputEvent) then) =
      __$$_ResetChatInputEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ResetChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_ResetChatInputEvent>
    implements _$$_ResetChatInputEventCopyWith<$Res> {
  __$$_ResetChatInputEventCopyWithImpl(_$_ResetChatInputEvent _value,
      $Res Function(_$_ResetChatInputEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ResetChatInputEvent
    with DiagnosticableTreeMixin
    implements _ResetChatInputEvent {
  const _$_ResetChatInputEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.reset()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ChatInputEvent.reset'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ResetChatInputEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return reset();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return reset?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return reset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return reset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(this);
    }
    return orElse();
  }
}

abstract class _ResetChatInputEvent implements ChatInputEvent {
  const factory _ResetChatInputEvent() = _$_ResetChatInputEvent;
}

/// @nodoc
abstract class _$$_UpdateRecorderTypeChatInputEventCopyWith<$Res> {
  factory _$$_UpdateRecorderTypeChatInputEventCopyWith(
          _$_UpdateRecorderTypeChatInputEvent value,
          $Res Function(_$_UpdateRecorderTypeChatInputEvent) then) =
      __$$_UpdateRecorderTypeChatInputEventCopyWithImpl<$Res>;
  @useResult
  $Res call({RecorderType val});
}

/// @nodoc
class __$$_UpdateRecorderTypeChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res,
        _$_UpdateRecorderTypeChatInputEvent>
    implements _$$_UpdateRecorderTypeChatInputEventCopyWith<$Res> {
  __$$_UpdateRecorderTypeChatInputEventCopyWithImpl(
      _$_UpdateRecorderTypeChatInputEvent _value,
      $Res Function(_$_UpdateRecorderTypeChatInputEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? val = null,
  }) {
    return _then(_$_UpdateRecorderTypeChatInputEvent(
      null == val
          ? _value.val
          : val // ignore: cast_nullable_to_non_nullable
              as RecorderType,
    ));
  }
}

/// @nodoc

class _$_UpdateRecorderTypeChatInputEvent
    with DiagnosticableTreeMixin
    implements _UpdateRecorderTypeChatInputEvent {
  const _$_UpdateRecorderTypeChatInputEvent(this.val);

  @override
  final RecorderType val;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.updateRecorderType(val: $val)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChatInputEvent.updateRecorderType'))
      ..add(DiagnosticsProperty('val', val));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UpdateRecorderTypeChatInputEvent &&
            (identical(other.val, val) || other.val == val));
  }

  @override
  int get hashCode => Object.hash(runtimeType, val);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UpdateRecorderTypeChatInputEventCopyWith<
          _$_UpdateRecorderTypeChatInputEvent>
      get copyWith => __$$_UpdateRecorderTypeChatInputEventCopyWithImpl<
          _$_UpdateRecorderTypeChatInputEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return updateRecorderType(val);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return updateRecorderType?.call(val);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (updateRecorderType != null) {
      return updateRecorderType(val);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return updateRecorderType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return updateRecorderType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (updateRecorderType != null) {
      return updateRecorderType(this);
    }
    return orElse();
  }
}

abstract class _UpdateRecorderTypeChatInputEvent implements ChatInputEvent {
  const factory _UpdateRecorderTypeChatInputEvent(final RecorderType val) =
      _$_UpdateRecorderTypeChatInputEvent;

  RecorderType get val;
  @JsonKey(ignore: true)
  _$$_UpdateRecorderTypeChatInputEventCopyWith<
          _$_UpdateRecorderTypeChatInputEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_AudioStartRecChatInputEventCopyWith<$Res> {
  factory _$$_AudioStartRecChatInputEventCopyWith(
          _$_AudioStartRecChatInputEvent value,
          $Res Function(_$_AudioStartRecChatInputEvent) then) =
      __$$_AudioStartRecChatInputEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AudioStartRecChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_AudioStartRecChatInputEvent>
    implements _$$_AudioStartRecChatInputEventCopyWith<$Res> {
  __$$_AudioStartRecChatInputEventCopyWithImpl(
      _$_AudioStartRecChatInputEvent _value,
      $Res Function(_$_AudioStartRecChatInputEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AudioStartRecChatInputEvent
    with DiagnosticableTreeMixin
    implements _AudioStartRecChatInputEvent {
  const _$_AudioStartRecChatInputEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.audioStartRec()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ChatInputEvent.audioStartRec'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AudioStartRecChatInputEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return audioStartRec();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return audioStartRec?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (audioStartRec != null) {
      return audioStartRec();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return audioStartRec(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return audioStartRec?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (audioStartRec != null) {
      return audioStartRec(this);
    }
    return orElse();
  }
}

abstract class _AudioStartRecChatInputEvent implements ChatInputEvent {
  const factory _AudioStartRecChatInputEvent() = _$_AudioStartRecChatInputEvent;
}

/// @nodoc
abstract class _$$_AudioStopRecChatInputEventCopyWith<$Res> {
  factory _$$_AudioStopRecChatInputEventCopyWith(
          _$_AudioStopRecChatInputEvent value,
          $Res Function(_$_AudioStopRecChatInputEvent) then) =
      __$$_AudioStopRecChatInputEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AudioStopRecChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_AudioStopRecChatInputEvent>
    implements _$$_AudioStopRecChatInputEventCopyWith<$Res> {
  __$$_AudioStopRecChatInputEventCopyWithImpl(
      _$_AudioStopRecChatInputEvent _value,
      $Res Function(_$_AudioStopRecChatInputEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AudioStopRecChatInputEvent
    with DiagnosticableTreeMixin
    implements _AudioStopRecChatInputEvent {
  const _$_AudioStopRecChatInputEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.audioStopRec()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ChatInputEvent.audioStopRec'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AudioStopRecChatInputEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return audioStopRec();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return audioStopRec?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (audioStopRec != null) {
      return audioStopRec();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return audioStopRec(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return audioStopRec?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (audioStopRec != null) {
      return audioStopRec(this);
    }
    return orElse();
  }
}

abstract class _AudioStopRecChatInputEvent implements ChatInputEvent {
  const factory _AudioStopRecChatInputEvent() = _$_AudioStopRecChatInputEvent;
}

/// @nodoc
abstract class _$$_AudioCancelRecChatInputEventCopyWith<$Res> {
  factory _$$_AudioCancelRecChatInputEventCopyWith(
          _$_AudioCancelRecChatInputEvent value,
          $Res Function(_$_AudioCancelRecChatInputEvent) then) =
      __$$_AudioCancelRecChatInputEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AudioCancelRecChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_AudioCancelRecChatInputEvent>
    implements _$$_AudioCancelRecChatInputEventCopyWith<$Res> {
  __$$_AudioCancelRecChatInputEventCopyWithImpl(
      _$_AudioCancelRecChatInputEvent _value,
      $Res Function(_$_AudioCancelRecChatInputEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AudioCancelRecChatInputEvent
    with DiagnosticableTreeMixin
    implements _AudioCancelRecChatInputEvent {
  const _$_AudioCancelRecChatInputEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.audioCancelRec()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'ChatInputEvent.audioCancelRec'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AudioCancelRecChatInputEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return audioCancelRec();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return audioCancelRec?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (audioCancelRec != null) {
      return audioCancelRec();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return audioCancelRec(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return audioCancelRec?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (audioCancelRec != null) {
      return audioCancelRec(this);
    }
    return orElse();
  }
}

abstract class _AudioCancelRecChatInputEvent implements ChatInputEvent {
  const factory _AudioCancelRecChatInputEvent() =
      _$_AudioCancelRecChatInputEvent;
}

/// @nodoc
abstract class _$$_VideoStartRecChatInputEventCopyWith<$Res> {
  factory _$$_VideoStartRecChatInputEventCopyWith(
          _$_VideoStartRecChatInputEvent value,
          $Res Function(_$_VideoStartRecChatInputEvent) then) =
      __$$_VideoStartRecChatInputEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_VideoStartRecChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_VideoStartRecChatInputEvent>
    implements _$$_VideoStartRecChatInputEventCopyWith<$Res> {
  __$$_VideoStartRecChatInputEventCopyWithImpl(
      _$_VideoStartRecChatInputEvent _value,
      $Res Function(_$_VideoStartRecChatInputEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_VideoStartRecChatInputEvent
    with DiagnosticableTreeMixin
    implements _VideoStartRecChatInputEvent {
  const _$_VideoStartRecChatInputEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.videoStartRec()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ChatInputEvent.videoStartRec'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_VideoStartRecChatInputEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return videoStartRec();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return videoStartRec?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (videoStartRec != null) {
      return videoStartRec();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return videoStartRec(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return videoStartRec?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (videoStartRec != null) {
      return videoStartRec(this);
    }
    return orElse();
  }
}

abstract class _VideoStartRecChatInputEvent implements ChatInputEvent {
  const factory _VideoStartRecChatInputEvent() = _$_VideoStartRecChatInputEvent;
}

/// @nodoc
abstract class _$$_VideoStopRecChatInputEventCopyWith<$Res> {
  factory _$$_VideoStopRecChatInputEventCopyWith(
          _$_VideoStopRecChatInputEvent value,
          $Res Function(_$_VideoStopRecChatInputEvent) then) =
      __$$_VideoStopRecChatInputEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_VideoStopRecChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_VideoStopRecChatInputEvent>
    implements _$$_VideoStopRecChatInputEventCopyWith<$Res> {
  __$$_VideoStopRecChatInputEventCopyWithImpl(
      _$_VideoStopRecChatInputEvent _value,
      $Res Function(_$_VideoStopRecChatInputEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_VideoStopRecChatInputEvent
    with DiagnosticableTreeMixin
    implements _VideoStopRecChatInputEvent {
  const _$_VideoStopRecChatInputEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.videoStopRec()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ChatInputEvent.videoStopRec'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_VideoStopRecChatInputEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return videoStopRec();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return videoStopRec?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (videoStopRec != null) {
      return videoStopRec();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return videoStopRec(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return videoStopRec?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (videoStopRec != null) {
      return videoStopRec(this);
    }
    return orElse();
  }
}

abstract class _VideoStopRecChatInputEvent implements ChatInputEvent {
  const factory _VideoStopRecChatInputEvent() = _$_VideoStopRecChatInputEvent;
}

/// @nodoc
abstract class _$$_VideoCancelRecChatInputEventCopyWith<$Res> {
  factory _$$_VideoCancelRecChatInputEventCopyWith(
          _$_VideoCancelRecChatInputEvent value,
          $Res Function(_$_VideoCancelRecChatInputEvent) then) =
      __$$_VideoCancelRecChatInputEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_VideoCancelRecChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_VideoCancelRecChatInputEvent>
    implements _$$_VideoCancelRecChatInputEventCopyWith<$Res> {
  __$$_VideoCancelRecChatInputEventCopyWithImpl(
      _$_VideoCancelRecChatInputEvent _value,
      $Res Function(_$_VideoCancelRecChatInputEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_VideoCancelRecChatInputEvent
    with DiagnosticableTreeMixin
    implements _VideoCancelRecChatInputEvent {
  const _$_VideoCancelRecChatInputEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.videoCancelRec()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
        .add(DiagnosticsProperty('type', 'ChatInputEvent.videoCancelRec'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_VideoCancelRecChatInputEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return videoCancelRec();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return videoCancelRec?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (videoCancelRec != null) {
      return videoCancelRec();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return videoCancelRec(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return videoCancelRec?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (videoCancelRec != null) {
      return videoCancelRec(this);
    }
    return orElse();
  }
}

abstract class _VideoCancelRecChatInputEvent implements ChatInputEvent {
  const factory _VideoCancelRecChatInputEvent() =
      _$_VideoCancelRecChatInputEvent;
}

/// @nodoc
abstract class _$$_SetRecordingChatInputEventCopyWith<$Res> {
  factory _$$_SetRecordingChatInputEventCopyWith(
          _$_SetRecordingChatInputEvent value,
          $Res Function(_$_SetRecordingChatInputEvent) then) =
      __$$_SetRecordingChatInputEventCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isRecording});
}

/// @nodoc
class __$$_SetRecordingChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_SetRecordingChatInputEvent>
    implements _$$_SetRecordingChatInputEventCopyWith<$Res> {
  __$$_SetRecordingChatInputEventCopyWithImpl(
      _$_SetRecordingChatInputEvent _value,
      $Res Function(_$_SetRecordingChatInputEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isRecording = null,
  }) {
    return _then(_$_SetRecordingChatInputEvent(
      null == isRecording
          ? _value.isRecording
          : isRecording // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_SetRecordingChatInputEvent
    with DiagnosticableTreeMixin
    implements _SetRecordingChatInputEvent {
  const _$_SetRecordingChatInputEvent(this.isRecording);

  @override
  final bool isRecording;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.setRecording(isRecording: $isRecording)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChatInputEvent.setRecording'))
      ..add(DiagnosticsProperty('isRecording', isRecording));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SetRecordingChatInputEvent &&
            (identical(other.isRecording, isRecording) ||
                other.isRecording == isRecording));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isRecording);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SetRecordingChatInputEventCopyWith<_$_SetRecordingChatInputEvent>
      get copyWith => __$$_SetRecordingChatInputEventCopyWithImpl<
          _$_SetRecordingChatInputEvent>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return setRecording(isRecording);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return setRecording?.call(isRecording);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (setRecording != null) {
      return setRecording(isRecording);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return setRecording(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return setRecording?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (setRecording != null) {
      return setRecording(this);
    }
    return orElse();
  }
}

abstract class _SetRecordingChatInputEvent implements ChatInputEvent {
  const factory _SetRecordingChatInputEvent(final bool isRecording) =
      _$_SetRecordingChatInputEvent;

  bool get isRecording;
  @JsonKey(ignore: true)
  _$$_SetRecordingChatInputEventCopyWith<_$_SetRecordingChatInputEvent>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ShowAtChatInputEventCopyWith<$Res> {
  factory _$$_ShowAtChatInputEventCopyWith(_$_ShowAtChatInputEvent value,
          $Res Function(_$_ShowAtChatInputEvent) then) =
      __$$_ShowAtChatInputEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ShowAtChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_ShowAtChatInputEvent>
    implements _$$_ShowAtChatInputEventCopyWith<$Res> {
  __$$_ShowAtChatInputEventCopyWithImpl(_$_ShowAtChatInputEvent _value,
      $Res Function(_$_ShowAtChatInputEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ShowAtChatInputEvent
    with DiagnosticableTreeMixin
    implements _ShowAtChatInputEvent {
  const _$_ShowAtChatInputEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.showAt()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ChatInputEvent.showAt'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ShowAtChatInputEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return showAt();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return showAt?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (showAt != null) {
      return showAt();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return showAt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return showAt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (showAt != null) {
      return showAt(this);
    }
    return orElse();
  }
}

abstract class _ShowAtChatInputEvent implements ChatInputEvent {
  const factory _ShowAtChatInputEvent() = _$_ShowAtChatInputEvent;
}

/// @nodoc
abstract class _$$_ShowEmojiChatInputEventCopyWith<$Res> {
  factory _$$_ShowEmojiChatInputEventCopyWith(_$_ShowEmojiChatInputEvent value,
          $Res Function(_$_ShowEmojiChatInputEvent) then) =
      __$$_ShowEmojiChatInputEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ShowEmojiChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_ShowEmojiChatInputEvent>
    implements _$$_ShowEmojiChatInputEventCopyWith<$Res> {
  __$$_ShowEmojiChatInputEventCopyWithImpl(_$_ShowEmojiChatInputEvent _value,
      $Res Function(_$_ShowEmojiChatInputEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ShowEmojiChatInputEvent
    with DiagnosticableTreeMixin
    implements _ShowEmojiChatInputEvent {
  const _$_ShowEmojiChatInputEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.showEmoji()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ChatInputEvent.showEmoji'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ShowEmojiChatInputEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return showEmoji();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return showEmoji?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (showEmoji != null) {
      return showEmoji();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return showEmoji(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return showEmoji?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (showEmoji != null) {
      return showEmoji(this);
    }
    return orElse();
  }
}

abstract class _ShowEmojiChatInputEvent implements ChatInputEvent {
  const factory _ShowEmojiChatInputEvent() = _$_ShowEmojiChatInputEvent;
}

/// @nodoc
abstract class _$$_ShowFormatterChatInputEventCopyWith<$Res> {
  factory _$$_ShowFormatterChatInputEventCopyWith(
          _$_ShowFormatterChatInputEvent value,
          $Res Function(_$_ShowFormatterChatInputEvent) then) =
      __$$_ShowFormatterChatInputEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ShowFormatterChatInputEventCopyWithImpl<$Res>
    extends _$ChatInputEventCopyWithImpl<$Res, _$_ShowFormatterChatInputEvent>
    implements _$$_ShowFormatterChatInputEventCopyWith<$Res> {
  __$$_ShowFormatterChatInputEventCopyWithImpl(
      _$_ShowFormatterChatInputEvent _value,
      $Res Function(_$_ShowFormatterChatInputEvent) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ShowFormatterChatInputEvent
    with DiagnosticableTreeMixin
    implements _ShowFormatterChatInputEvent {
  const _$_ShowFormatterChatInputEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputEvent.showFormatter()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'ChatInputEvent.showFormatter'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ShowFormatterChatInputEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Document message) update,
    required TResult Function(List<DLSFile> files) attachFiles,
    required TResult Function(String key) detachFile,
    required TResult Function() reset,
    required TResult Function(RecorderType val) updateRecorderType,
    required TResult Function() audioStartRec,
    required TResult Function() audioStopRec,
    required TResult Function() audioCancelRec,
    required TResult Function() videoStartRec,
    required TResult Function() videoStopRec,
    required TResult Function() videoCancelRec,
    required TResult Function(bool isRecording) setRecording,
    required TResult Function() showAt,
    required TResult Function() showEmoji,
    required TResult Function() showFormatter,
  }) {
    return showFormatter();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Document message)? update,
    TResult? Function(List<DLSFile> files)? attachFiles,
    TResult? Function(String key)? detachFile,
    TResult? Function()? reset,
    TResult? Function(RecorderType val)? updateRecorderType,
    TResult? Function()? audioStartRec,
    TResult? Function()? audioStopRec,
    TResult? Function()? audioCancelRec,
    TResult? Function()? videoStartRec,
    TResult? Function()? videoStopRec,
    TResult? Function()? videoCancelRec,
    TResult? Function(bool isRecording)? setRecording,
    TResult? Function()? showAt,
    TResult? Function()? showEmoji,
    TResult? Function()? showFormatter,
  }) {
    return showFormatter?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Document message)? update,
    TResult Function(List<DLSFile> files)? attachFiles,
    TResult Function(String key)? detachFile,
    TResult Function()? reset,
    TResult Function(RecorderType val)? updateRecorderType,
    TResult Function()? audioStartRec,
    TResult Function()? audioStopRec,
    TResult Function()? audioCancelRec,
    TResult Function()? videoStartRec,
    TResult Function()? videoStopRec,
    TResult Function()? videoCancelRec,
    TResult Function(bool isRecording)? setRecording,
    TResult Function()? showAt,
    TResult Function()? showEmoji,
    TResult Function()? showFormatter,
    required TResult orElse(),
  }) {
    if (showFormatter != null) {
      return showFormatter();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateChatInputEvent value) update,
    required TResult Function(_AttachFilesChatInputEvent value) attachFiles,
    required TResult Function(_DetachFileChatInputEvent value) detachFile,
    required TResult Function(_ResetChatInputEvent value) reset,
    required TResult Function(_UpdateRecorderTypeChatInputEvent value)
        updateRecorderType,
    required TResult Function(_AudioStartRecChatInputEvent value) audioStartRec,
    required TResult Function(_AudioStopRecChatInputEvent value) audioStopRec,
    required TResult Function(_AudioCancelRecChatInputEvent value)
        audioCancelRec,
    required TResult Function(_VideoStartRecChatInputEvent value) videoStartRec,
    required TResult Function(_VideoStopRecChatInputEvent value) videoStopRec,
    required TResult Function(_VideoCancelRecChatInputEvent value)
        videoCancelRec,
    required TResult Function(_SetRecordingChatInputEvent value) setRecording,
    required TResult Function(_ShowAtChatInputEvent value) showAt,
    required TResult Function(_ShowEmojiChatInputEvent value) showEmoji,
    required TResult Function(_ShowFormatterChatInputEvent value) showFormatter,
  }) {
    return showFormatter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateChatInputEvent value)? update,
    TResult? Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult? Function(_DetachFileChatInputEvent value)? detachFile,
    TResult? Function(_ResetChatInputEvent value)? reset,
    TResult? Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult? Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult? Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult? Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult? Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult? Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult? Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult? Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult? Function(_ShowAtChatInputEvent value)? showAt,
    TResult? Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult? Function(_ShowFormatterChatInputEvent value)? showFormatter,
  }) {
    return showFormatter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateChatInputEvent value)? update,
    TResult Function(_AttachFilesChatInputEvent value)? attachFiles,
    TResult Function(_DetachFileChatInputEvent value)? detachFile,
    TResult Function(_ResetChatInputEvent value)? reset,
    TResult Function(_UpdateRecorderTypeChatInputEvent value)?
        updateRecorderType,
    TResult Function(_AudioStartRecChatInputEvent value)? audioStartRec,
    TResult Function(_AudioStopRecChatInputEvent value)? audioStopRec,
    TResult Function(_AudioCancelRecChatInputEvent value)? audioCancelRec,
    TResult Function(_VideoStartRecChatInputEvent value)? videoStartRec,
    TResult Function(_VideoStopRecChatInputEvent value)? videoStopRec,
    TResult Function(_VideoCancelRecChatInputEvent value)? videoCancelRec,
    TResult Function(_SetRecordingChatInputEvent value)? setRecording,
    TResult Function(_ShowAtChatInputEvent value)? showAt,
    TResult Function(_ShowEmojiChatInputEvent value)? showEmoji,
    TResult Function(_ShowFormatterChatInputEvent value)? showFormatter,
    required TResult orElse(),
  }) {
    if (showFormatter != null) {
      return showFormatter(this);
    }
    return orElse();
  }
}

abstract class _ShowFormatterChatInputEvent implements ChatInputEvent {
  const factory _ShowFormatterChatInputEvent() = _$_ShowFormatterChatInputEvent;
}

/// @nodoc
mixin _$ChatInputState {
  bool get atShowing => throw _privateConstructorUsedError;
  bool get emojiShowing => throw _privateConstructorUsedError;
  bool get formatterShowing => throw _privateConstructorUsedError;
  bool get isRecording => throw _privateConstructorUsedError;
  RecorderType get recorderType => throw _privateConstructorUsedError;
  Document get message => throw _privateConstructorUsedError;
  List<DLSFile> get files => throw _privateConstructorUsedError;
  String? get transaction => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)
        hasPayload,
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)
        loading,
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)
        failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        hasPayload,
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        loading,
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        hasPayload,
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        loading,
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HasPayloadChatInputState value) hasPayload,
    required TResult Function(_LoadingChatInputState value) loading,
    required TResult Function(_FailureChatInputState value) failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_HasPayloadChatInputState value)? hasPayload,
    TResult? Function(_LoadingChatInputState value)? loading,
    TResult? Function(_FailureChatInputState value)? failure,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HasPayloadChatInputState value)? hasPayload,
    TResult Function(_LoadingChatInputState value)? loading,
    TResult Function(_FailureChatInputState value)? failure,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ChatInputStateCopyWith<ChatInputState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChatInputStateCopyWith<$Res> {
  factory $ChatInputStateCopyWith(
          ChatInputState value, $Res Function(ChatInputState) then) =
      _$ChatInputStateCopyWithImpl<$Res, ChatInputState>;
  @useResult
  $Res call(
      {bool atShowing,
      bool emojiShowing,
      bool formatterShowing,
      bool isRecording,
      RecorderType recorderType,
      Document message,
      List<DLSFile> files,
      String? transaction});
}

/// @nodoc
class _$ChatInputStateCopyWithImpl<$Res, $Val extends ChatInputState>
    implements $ChatInputStateCopyWith<$Res> {
  _$ChatInputStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? atShowing = null,
    Object? emojiShowing = null,
    Object? formatterShowing = null,
    Object? isRecording = null,
    Object? recorderType = null,
    Object? message = null,
    Object? files = null,
    Object? transaction = freezed,
  }) {
    return _then(_value.copyWith(
      atShowing: null == atShowing
          ? _value.atShowing
          : atShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      emojiShowing: null == emojiShowing
          ? _value.emojiShowing
          : emojiShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      formatterShowing: null == formatterShowing
          ? _value.formatterShowing
          : formatterShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      isRecording: null == isRecording
          ? _value.isRecording
          : isRecording // ignore: cast_nullable_to_non_nullable
              as bool,
      recorderType: null == recorderType
          ? _value.recorderType
          : recorderType // ignore: cast_nullable_to_non_nullable
              as RecorderType,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as Document,
      files: null == files
          ? _value.files
          : files // ignore: cast_nullable_to_non_nullable
              as List<DLSFile>,
      transaction: freezed == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_HasPayloadChatInputStateCopyWith<$Res>
    implements $ChatInputStateCopyWith<$Res> {
  factory _$$_HasPayloadChatInputStateCopyWith(
          _$_HasPayloadChatInputState value,
          $Res Function(_$_HasPayloadChatInputState) then) =
      __$$_HasPayloadChatInputStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool atShowing,
      bool emojiShowing,
      bool formatterShowing,
      bool isRecording,
      RecorderType recorderType,
      Document message,
      List<DLSFile> files,
      String? transaction});
}

/// @nodoc
class __$$_HasPayloadChatInputStateCopyWithImpl<$Res>
    extends _$ChatInputStateCopyWithImpl<$Res, _$_HasPayloadChatInputState>
    implements _$$_HasPayloadChatInputStateCopyWith<$Res> {
  __$$_HasPayloadChatInputStateCopyWithImpl(_$_HasPayloadChatInputState _value,
      $Res Function(_$_HasPayloadChatInputState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? atShowing = null,
    Object? emojiShowing = null,
    Object? formatterShowing = null,
    Object? isRecording = null,
    Object? recorderType = null,
    Object? message = null,
    Object? files = null,
    Object? transaction = freezed,
  }) {
    return _then(_$_HasPayloadChatInputState(
      atShowing: null == atShowing
          ? _value.atShowing
          : atShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      emojiShowing: null == emojiShowing
          ? _value.emojiShowing
          : emojiShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      formatterShowing: null == formatterShowing
          ? _value.formatterShowing
          : formatterShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      isRecording: null == isRecording
          ? _value.isRecording
          : isRecording // ignore: cast_nullable_to_non_nullable
              as bool,
      recorderType: null == recorderType
          ? _value.recorderType
          : recorderType // ignore: cast_nullable_to_non_nullable
              as RecorderType,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as Document,
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as List<DLSFile>,
      transaction: freezed == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_HasPayloadChatInputState extends _HasPayloadChatInputState
    with DiagnosticableTreeMixin {
  const _$_HasPayloadChatInputState(
      {required this.atShowing,
      required this.emojiShowing,
      required this.formatterShowing,
      required this.isRecording,
      required this.recorderType,
      required this.message,
      required final List<DLSFile> files,
      this.transaction})
      : _files = files,
        super._();

  @override
  final bool atShowing;
  @override
  final bool emojiShowing;
  @override
  final bool formatterShowing;
  @override
  final bool isRecording;
  @override
  final RecorderType recorderType;
  @override
  final Document message;
  final List<DLSFile> _files;
  @override
  List<DLSFile> get files {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_files);
  }

  @override
  final String? transaction;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputState.hasPayload(atShowing: $atShowing, emojiShowing: $emojiShowing, formatterShowing: $formatterShowing, isRecording: $isRecording, recorderType: $recorderType, message: $message, files: $files, transaction: $transaction)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChatInputState.hasPayload'))
      ..add(DiagnosticsProperty('atShowing', atShowing))
      ..add(DiagnosticsProperty('emojiShowing', emojiShowing))
      ..add(DiagnosticsProperty('formatterShowing', formatterShowing))
      ..add(DiagnosticsProperty('isRecording', isRecording))
      ..add(DiagnosticsProperty('recorderType', recorderType))
      ..add(DiagnosticsProperty('message', message))
      ..add(DiagnosticsProperty('files', files))
      ..add(DiagnosticsProperty('transaction', transaction));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_HasPayloadChatInputState &&
            (identical(other.atShowing, atShowing) ||
                other.atShowing == atShowing) &&
            (identical(other.emojiShowing, emojiShowing) ||
                other.emojiShowing == emojiShowing) &&
            (identical(other.formatterShowing, formatterShowing) ||
                other.formatterShowing == formatterShowing) &&
            (identical(other.isRecording, isRecording) ||
                other.isRecording == isRecording) &&
            (identical(other.recorderType, recorderType) ||
                other.recorderType == recorderType) &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._files, _files) &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      atShowing,
      emojiShowing,
      formatterShowing,
      isRecording,
      recorderType,
      message,
      const DeepCollectionEquality().hash(_files),
      transaction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_HasPayloadChatInputStateCopyWith<_$_HasPayloadChatInputState>
      get copyWith => __$$_HasPayloadChatInputStateCopyWithImpl<
          _$_HasPayloadChatInputState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)
        hasPayload,
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)
        loading,
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)
        failure,
  }) {
    return hasPayload(atShowing, emojiShowing, formatterShowing, isRecording,
        recorderType, message, files, transaction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        hasPayload,
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        loading,
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        failure,
  }) {
    return hasPayload?.call(atShowing, emojiShowing, formatterShowing,
        isRecording, recorderType, message, files, transaction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        hasPayload,
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        loading,
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        failure,
    required TResult orElse(),
  }) {
    if (hasPayload != null) {
      return hasPayload(atShowing, emojiShowing, formatterShowing, isRecording,
          recorderType, message, files, transaction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HasPayloadChatInputState value) hasPayload,
    required TResult Function(_LoadingChatInputState value) loading,
    required TResult Function(_FailureChatInputState value) failure,
  }) {
    return hasPayload(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_HasPayloadChatInputState value)? hasPayload,
    TResult? Function(_LoadingChatInputState value)? loading,
    TResult? Function(_FailureChatInputState value)? failure,
  }) {
    return hasPayload?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HasPayloadChatInputState value)? hasPayload,
    TResult Function(_LoadingChatInputState value)? loading,
    TResult Function(_FailureChatInputState value)? failure,
    required TResult orElse(),
  }) {
    if (hasPayload != null) {
      return hasPayload(this);
    }
    return orElse();
  }
}

abstract class _HasPayloadChatInputState extends ChatInputState {
  const factory _HasPayloadChatInputState(
      {required final bool atShowing,
      required final bool emojiShowing,
      required final bool formatterShowing,
      required final bool isRecording,
      required final RecorderType recorderType,
      required final Document message,
      required final List<DLSFile> files,
      final String? transaction}) = _$_HasPayloadChatInputState;
  const _HasPayloadChatInputState._() : super._();

  @override
  bool get atShowing;
  @override
  bool get emojiShowing;
  @override
  bool get formatterShowing;
  @override
  bool get isRecording;
  @override
  RecorderType get recorderType;
  @override
  Document get message;
  @override
  List<DLSFile> get files;
  @override
  String? get transaction;
  @override
  @JsonKey(ignore: true)
  _$$_HasPayloadChatInputStateCopyWith<_$_HasPayloadChatInputState>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_LoadingChatInputStateCopyWith<$Res>
    implements $ChatInputStateCopyWith<$Res> {
  factory _$$_LoadingChatInputStateCopyWith(_$_LoadingChatInputState value,
          $Res Function(_$_LoadingChatInputState) then) =
      __$$_LoadingChatInputStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool atShowing,
      bool emojiShowing,
      bool formatterShowing,
      bool isRecording,
      RecorderType recorderType,
      Document message,
      List<DLSFile> files,
      String? transaction});
}

/// @nodoc
class __$$_LoadingChatInputStateCopyWithImpl<$Res>
    extends _$ChatInputStateCopyWithImpl<$Res, _$_LoadingChatInputState>
    implements _$$_LoadingChatInputStateCopyWith<$Res> {
  __$$_LoadingChatInputStateCopyWithImpl(_$_LoadingChatInputState _value,
      $Res Function(_$_LoadingChatInputState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? atShowing = null,
    Object? emojiShowing = null,
    Object? formatterShowing = null,
    Object? isRecording = null,
    Object? recorderType = null,
    Object? message = null,
    Object? files = null,
    Object? transaction = freezed,
  }) {
    return _then(_$_LoadingChatInputState(
      atShowing: null == atShowing
          ? _value.atShowing
          : atShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      emojiShowing: null == emojiShowing
          ? _value.emojiShowing
          : emojiShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      formatterShowing: null == formatterShowing
          ? _value.formatterShowing
          : formatterShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      isRecording: null == isRecording
          ? _value.isRecording
          : isRecording // ignore: cast_nullable_to_non_nullable
              as bool,
      recorderType: null == recorderType
          ? _value.recorderType
          : recorderType // ignore: cast_nullable_to_non_nullable
              as RecorderType,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as Document,
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as List<DLSFile>,
      transaction: freezed == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_LoadingChatInputState extends _LoadingChatInputState
    with DiagnosticableTreeMixin {
  const _$_LoadingChatInputState(
      {required this.atShowing,
      required this.emojiShowing,
      required this.formatterShowing,
      required this.isRecording,
      required this.recorderType,
      required this.message,
      required final List<DLSFile> files,
      this.transaction})
      : _files = files,
        super._();

  @override
  final bool atShowing;
  @override
  final bool emojiShowing;
  @override
  final bool formatterShowing;
  @override
  final bool isRecording;
  @override
  final RecorderType recorderType;
  @override
  final Document message;
  final List<DLSFile> _files;
  @override
  List<DLSFile> get files {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_files);
  }

  @override
  final String? transaction;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputState.loading(atShowing: $atShowing, emojiShowing: $emojiShowing, formatterShowing: $formatterShowing, isRecording: $isRecording, recorderType: $recorderType, message: $message, files: $files, transaction: $transaction)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChatInputState.loading'))
      ..add(DiagnosticsProperty('atShowing', atShowing))
      ..add(DiagnosticsProperty('emojiShowing', emojiShowing))
      ..add(DiagnosticsProperty('formatterShowing', formatterShowing))
      ..add(DiagnosticsProperty('isRecording', isRecording))
      ..add(DiagnosticsProperty('recorderType', recorderType))
      ..add(DiagnosticsProperty('message', message))
      ..add(DiagnosticsProperty('files', files))
      ..add(DiagnosticsProperty('transaction', transaction));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LoadingChatInputState &&
            (identical(other.atShowing, atShowing) ||
                other.atShowing == atShowing) &&
            (identical(other.emojiShowing, emojiShowing) ||
                other.emojiShowing == emojiShowing) &&
            (identical(other.formatterShowing, formatterShowing) ||
                other.formatterShowing == formatterShowing) &&
            (identical(other.isRecording, isRecording) ||
                other.isRecording == isRecording) &&
            (identical(other.recorderType, recorderType) ||
                other.recorderType == recorderType) &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._files, _files) &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      atShowing,
      emojiShowing,
      formatterShowing,
      isRecording,
      recorderType,
      message,
      const DeepCollectionEquality().hash(_files),
      transaction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LoadingChatInputStateCopyWith<_$_LoadingChatInputState> get copyWith =>
      __$$_LoadingChatInputStateCopyWithImpl<_$_LoadingChatInputState>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)
        hasPayload,
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)
        loading,
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)
        failure,
  }) {
    return loading(atShowing, emojiShowing, formatterShowing, isRecording,
        recorderType, message, files, transaction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        hasPayload,
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        loading,
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        failure,
  }) {
    return loading?.call(atShowing, emojiShowing, formatterShowing, isRecording,
        recorderType, message, files, transaction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        hasPayload,
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        loading,
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        failure,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(atShowing, emojiShowing, formatterShowing, isRecording,
          recorderType, message, files, transaction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HasPayloadChatInputState value) hasPayload,
    required TResult Function(_LoadingChatInputState value) loading,
    required TResult Function(_FailureChatInputState value) failure,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_HasPayloadChatInputState value)? hasPayload,
    TResult? Function(_LoadingChatInputState value)? loading,
    TResult? Function(_FailureChatInputState value)? failure,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HasPayloadChatInputState value)? hasPayload,
    TResult Function(_LoadingChatInputState value)? loading,
    TResult Function(_FailureChatInputState value)? failure,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _LoadingChatInputState extends ChatInputState {
  const factory _LoadingChatInputState(
      {required final bool atShowing,
      required final bool emojiShowing,
      required final bool formatterShowing,
      required final bool isRecording,
      required final RecorderType recorderType,
      required final Document message,
      required final List<DLSFile> files,
      final String? transaction}) = _$_LoadingChatInputState;
  const _LoadingChatInputState._() : super._();

  @override
  bool get atShowing;
  @override
  bool get emojiShowing;
  @override
  bool get formatterShowing;
  @override
  bool get isRecording;
  @override
  RecorderType get recorderType;
  @override
  Document get message;
  @override
  List<DLSFile> get files;
  @override
  String? get transaction;
  @override
  @JsonKey(ignore: true)
  _$$_LoadingChatInputStateCopyWith<_$_LoadingChatInputState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_FailureChatInputStateCopyWith<$Res>
    implements $ChatInputStateCopyWith<$Res> {
  factory _$$_FailureChatInputStateCopyWith(_$_FailureChatInputState value,
          $Res Function(_$_FailureChatInputState) then) =
      __$$_FailureChatInputStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool atShowing,
      bool emojiShowing,
      bool formatterShowing,
      bool isRecording,
      RecorderType recorderType,
      String failureMessage,
      Document message,
      List<DLSFile> files,
      String? transaction});
}

/// @nodoc
class __$$_FailureChatInputStateCopyWithImpl<$Res>
    extends _$ChatInputStateCopyWithImpl<$Res, _$_FailureChatInputState>
    implements _$$_FailureChatInputStateCopyWith<$Res> {
  __$$_FailureChatInputStateCopyWithImpl(_$_FailureChatInputState _value,
      $Res Function(_$_FailureChatInputState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? atShowing = null,
    Object? emojiShowing = null,
    Object? formatterShowing = null,
    Object? isRecording = null,
    Object? recorderType = null,
    Object? failureMessage = null,
    Object? message = null,
    Object? files = null,
    Object? transaction = freezed,
  }) {
    return _then(_$_FailureChatInputState(
      atShowing: null == atShowing
          ? _value.atShowing
          : atShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      emojiShowing: null == emojiShowing
          ? _value.emojiShowing
          : emojiShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      formatterShowing: null == formatterShowing
          ? _value.formatterShowing
          : formatterShowing // ignore: cast_nullable_to_non_nullable
              as bool,
      isRecording: null == isRecording
          ? _value.isRecording
          : isRecording // ignore: cast_nullable_to_non_nullable
              as bool,
      recorderType: null == recorderType
          ? _value.recorderType
          : recorderType // ignore: cast_nullable_to_non_nullable
              as RecorderType,
      failureMessage: null == failureMessage
          ? _value.failureMessage
          : failureMessage // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as Document,
      files: null == files
          ? _value._files
          : files // ignore: cast_nullable_to_non_nullable
              as List<DLSFile>,
      transaction: freezed == transaction
          ? _value.transaction
          : transaction // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_FailureChatInputState extends _FailureChatInputState
    with DiagnosticableTreeMixin {
  const _$_FailureChatInputState(
      {required this.atShowing,
      required this.emojiShowing,
      required this.formatterShowing,
      required this.isRecording,
      required this.recorderType,
      required this.failureMessage,
      required this.message,
      required final List<DLSFile> files,
      this.transaction})
      : _files = files,
        super._();

  @override
  final bool atShowing;
  @override
  final bool emojiShowing;
  @override
  final bool formatterShowing;
  @override
  final bool isRecording;
  @override
  final RecorderType recorderType;
  @override
  final String failureMessage;
  @override
  final Document message;
  final List<DLSFile> _files;
  @override
  List<DLSFile> get files {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_files);
  }

  @override
  final String? transaction;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChatInputState.failure(atShowing: $atShowing, emojiShowing: $emojiShowing, formatterShowing: $formatterShowing, isRecording: $isRecording, recorderType: $recorderType, failureMessage: $failureMessage, message: $message, files: $files, transaction: $transaction)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChatInputState.failure'))
      ..add(DiagnosticsProperty('atShowing', atShowing))
      ..add(DiagnosticsProperty('emojiShowing', emojiShowing))
      ..add(DiagnosticsProperty('formatterShowing', formatterShowing))
      ..add(DiagnosticsProperty('isRecording', isRecording))
      ..add(DiagnosticsProperty('recorderType', recorderType))
      ..add(DiagnosticsProperty('failureMessage', failureMessage))
      ..add(DiagnosticsProperty('message', message))
      ..add(DiagnosticsProperty('files', files))
      ..add(DiagnosticsProperty('transaction', transaction));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FailureChatInputState &&
            (identical(other.atShowing, atShowing) ||
                other.atShowing == atShowing) &&
            (identical(other.emojiShowing, emojiShowing) ||
                other.emojiShowing == emojiShowing) &&
            (identical(other.formatterShowing, formatterShowing) ||
                other.formatterShowing == formatterShowing) &&
            (identical(other.isRecording, isRecording) ||
                other.isRecording == isRecording) &&
            (identical(other.recorderType, recorderType) ||
                other.recorderType == recorderType) &&
            (identical(other.failureMessage, failureMessage) ||
                other.failureMessage == failureMessage) &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._files, _files) &&
            (identical(other.transaction, transaction) ||
                other.transaction == transaction));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      atShowing,
      emojiShowing,
      formatterShowing,
      isRecording,
      recorderType,
      failureMessage,
      message,
      const DeepCollectionEquality().hash(_files),
      transaction);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FailureChatInputStateCopyWith<_$_FailureChatInputState> get copyWith =>
      __$$_FailureChatInputStateCopyWithImpl<_$_FailureChatInputState>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)
        hasPayload,
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)
        loading,
    required TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)
        failure,
  }) {
    return failure(atShowing, emojiShowing, formatterShowing, isRecording,
        recorderType, failureMessage, message, files, transaction);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        hasPayload,
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        loading,
    TResult? Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        failure,
  }) {
    return failure?.call(atShowing, emojiShowing, formatterShowing, isRecording,
        recorderType, failureMessage, message, files, transaction);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        hasPayload,
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        loading,
    TResult Function(
            bool atShowing,
            bool emojiShowing,
            bool formatterShowing,
            bool isRecording,
            RecorderType recorderType,
            String failureMessage,
            Document message,
            List<DLSFile> files,
            String? transaction)?
        failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(atShowing, emojiShowing, formatterShowing, isRecording,
          recorderType, failureMessage, message, files, transaction);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_HasPayloadChatInputState value) hasPayload,
    required TResult Function(_LoadingChatInputState value) loading,
    required TResult Function(_FailureChatInputState value) failure,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_HasPayloadChatInputState value)? hasPayload,
    TResult? Function(_LoadingChatInputState value)? loading,
    TResult? Function(_FailureChatInputState value)? failure,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_HasPayloadChatInputState value)? hasPayload,
    TResult Function(_LoadingChatInputState value)? loading,
    TResult Function(_FailureChatInputState value)? failure,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class _FailureChatInputState extends ChatInputState {
  const factory _FailureChatInputState(
      {required final bool atShowing,
      required final bool emojiShowing,
      required final bool formatterShowing,
      required final bool isRecording,
      required final RecorderType recorderType,
      required final String failureMessage,
      required final Document message,
      required final List<DLSFile> files,
      final String? transaction}) = _$_FailureChatInputState;
  const _FailureChatInputState._() : super._();

  @override
  bool get atShowing;
  @override
  bool get emojiShowing;
  @override
  bool get formatterShowing;
  @override
  bool get isRecording;
  @override
  RecorderType get recorderType;
  String get failureMessage;
  @override
  Document get message;
  @override
  List<DLSFile> get files;
  @override
  String? get transaction;
  @override
  @JsonKey(ignore: true)
  _$$_FailureChatInputStateCopyWith<_$_FailureChatInputState> get copyWith =>
      throw _privateConstructorUsedError;
}
